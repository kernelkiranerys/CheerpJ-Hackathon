<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/GamePanel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/GamePanel.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;&#10;public class GamePanel extends JPanel implements Runnable {&#10;&#10;    final int originalTileSize = 16;&#10;    final int scale = 3;&#10;&#10;    final int tileSize = originalTileSize * scale;&#10;    final int maxScreenCol = 16;&#10;    final int maxScreenRow = 12;&#10;    final int screenWidth = tileSize * maxScreenRow;&#10;    final int screenHeight = tileSize * maxScreenRow;&#10;&#10;    Thread gameThread;&#10;&#10;&#10;    public GamePanel() {&#10;        this.setPreferredSize(new Dimension(screenWidth, screenHeight));&#10;        this.setBackground(Color.blue);&#10;        this.setDoubleBuffered(true);&#10;    }&#10;&#10;    public void startGameThread(){&#10;        gameThread = new Thread(this);&#10;        gameThread.start();&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        while(gameThread != null){&#10;            System.out.println(&quot;Running&quot;);&#10;            // this loop will update data to rernder screen sprites and other game info&#10;            update();&#10;            // render&#10;            repaint();&#10;        }&#10;    }&#10;    public void update(){&#10;&#10;    }&#10;    public void paintComponent(Graphics g){&#10;        super.paintComponent(g);&#10;&#10;        Graphics2D g2 = (Graphics2D)g;&#10;        g2.setColor(Color.white);&#10;        g2.fillRect(100, 100, tileSize, tileSize);&#10;        g2.dispose();&#10;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;&#10;/**&#10; * Primary game drawing surface and main loop controller.&#10; *&#10; * &lt;p&gt;This JPanel subclass owns the game's timing thread and is responsible for:&#10; * - maintaining tile and screen size constants used by the renderer,&#10; * - starting the game loop thread,&#10; * - performing per-frame updates, and&#10; * - rendering the game to the panel.&lt;/p&gt;&#10; *&#10; * &lt;p&gt;It implements Runnable so the game loop can run on a dedicated thread&#10; * started via startGameThread().&lt;/p&gt;&#10; */&#10;public class GamePanel extends JPanel implements Runnable {&#10;&#10;    /**&#10;     * Base size of a single tile in pixels before scaling.&#10;     */&#10;    final int originalTileSize = 16;&#10;&#10;    /**&#10;     * Scaling factor applied to the original tile size.&#10;     */&#10;    final int scale = 3;&#10;&#10;    /**&#10;     * Size of one tile in pixels after scaling (originalTileSize * scale).&#10;     */&#10;    final int tileSize = originalTileSize * scale;&#10;&#10;    /**&#10;     * Number of horizontal tiles visible on the screen.&#10;     */&#10;    final int maxScreenCol = 16;&#10;&#10;    /**&#10;     * Number of vertical tiles visible on the screen.&#10;     */&#10;    final int maxScreenRow = 12;&#10;&#10;    /**&#10;     * Screen width in pixels (tileSize * number of columns).&#10;     */&#10;    final int screenWidth = tileSize * maxScreenRow;&#10;&#10;    /**&#10;     * Screen height in pixels (tileSize * number of rows).&#10;     */&#10;    final int screenHeight = tileSize * maxScreenRow;&#10;&#10;    /**&#10;     * Thread that runs the main game loop. Null when not running.&#10;     */&#10;    Thread gameThread;&#10;&#10;&#10;    /**&#10;     * Construct a GamePanel configured for the calculated screen size and&#10;     * basic double buffering. The background is initialized to blue.&#10;     */&#10;    public GamePanel() {&#10;        this.setPreferredSize(new Dimension(screenWidth, screenHeight));&#10;        this.setBackground(Color.blue);&#10;        this.setDoubleBuffered(true);&#10;    }&#10;&#10;    /**&#10;     * Start the game loop on a dedicated thread.&#10;     *&#10;     * &lt;p&gt;If the thread is already running, this will replace it with a new one&#10;     * and start that new game loop.&lt;/p&gt;&#10;     */&#10;    public void startGameThread(){&#10;        gameThread = new Thread(this);&#10;        gameThread.start();&#10;    }&#10;&#10;    /**&#10;     * Main game loop. Runs while gameThread is non-null.&#10;     *&#10;     * &lt;p&gt;The loop calls update() to change game state and repaint() to schedule&#10;     * a new frame render via paintComponent.&lt;/p&gt;&#10;     */&#10;    @Override&#10;    public void run() {&#10;        while(gameThread != null){&#10;            System.out.println(&quot;Running&quot;);&#10;            // this loop will update data to rernder screen sprites and other game info&#10;            update();&#10;            // render&#10;            repaint();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update game logic for the next frame.&#10;     *&#10;     * &lt;p&gt;Currently a placeholder intended to be filled with game update logic&#10;     * such as moving sprites, processing input, and handling collisions.&lt;/p&gt;&#10;     */&#10;    public void update(){&#10;&#10;    }&#10;&#10;    /**&#10;     * Render the current game state to the panel.&#10;     *&#10;     * @param g the Graphics context provided by Swing; never null when called by the paint system&#10;     */&#10;    public void paintComponent(Graphics g){&#10;        super.paintComponent(g);&#10;&#10;        Graphics2D g2 = (Graphics2D)g;&#10;        g2.setColor(Color.white);&#10;        g2.fillRect(100, 100, tileSize, tileSize);&#10;        g2.dispose();&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>